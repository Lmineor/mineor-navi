<template>
  <div
    class="min-h-[150px] w-auto rounded-lg border border-gray-200 bg-white px-3 py-2 dark:border-gray-800 dark:bg-gray-700">
    <div class="flex h-full flex-col justify-between">
      <div class="flex items-start justify-between gap-8 px-4 py-2">
        <div class="shrink">
          <UTooltip :text="library.name">
            <UButton class="flex flex-col gap-3" variant="ghost" :padded="false" truncate color="black" size="xl"
              :title="library.name" :to="library.url" target="_blank" rel="nofollow">
              <div class="w-full">
                <img :src="`/img/${logo}`" :alt="logo" class="h-12 w-12 drop-shadow-lg" />
              </div>
              <p class="font-medium tracking-wide w-20">{{ library.name }}</p>
            </UButton>
          </UTooltip>
          <p v-if="library.subName" class="-mt-1 text-xs">（{{ library.subName }}）</p>
        </div>
        <div class="flex flex-wrap place-content-end gap-1">
          <span class="text-sm">{{ library.description }}</span>
        </div>
      </div>
      <!-- Card footer -->
      <div class="mt-1 flex items-center justify-between">
        <div class="ml-1 flex">
          <UTooltip v-if="repoUrl" :text="$t('goTo', { name: 'github.com' })">
            <UButton icon="i-mdi-github" :to="repoUrl" target="_blank" rel="nofollow" variant="ghost" color="gray" />
          </UTooltip>
        </div>
        <div class="mr-2">
          <template v-for="buttonFilter in buttonFiltersToShow" :key="buttonFilter.id">
            <LibraryCardBadge class="w-20" :buttonFilter="buttonFilter" />
          </template>
          <!-- <span class="text-sm">{{ library.description }}</span> -->
          <!-- <UButton class="pointer-events-none" @click="isComponentPanelOpen = true" icon="i-mdi-github" size="xl"
            :label="`${nbComponents} ${$t('componentCount')}`" variant="ghost" color="primary" /> -->
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { getButtonFilters } from "@/data/filters"
import type { Library } from "@/types/libraries.types"
import type { ButtonFilter } from "@/types/filters.types"

const props = defineProps<{
  initialLibrary: Library
}>()

// required to mutate a prop
const library = ref(props.initialLibrary)
const isComponentPanelOpen = ref(false)
const colorMode = useColorMode()
const nbComponents = library.value.componentCount
const localePath = useLocalePath()

const { locale } = useI18n()
const buttonFilters = getButtonFilters(locale.value)

const buttonFiltersToShow = computed((): ButtonFilter[] => {
  /* Return the button filters (ordered by indexes, to keep consistency over the different cards) than must be showed on the card */

  let result: ButtonFilter[] = []
  for (let filterMatching of library.value.filterMatchings) {
    const buttonFilter = <ButtonFilter>findBy("id", filterMatching.id, buttonFilters)!
    result.push(buttonFilter)
  }
  return result.sort((a, b) => a.index - b.index)
})

const display = computed((): boolean => {
  /* Return true if this card should be displayed */
  const { touchedButtonFilterIDs, rangeFiltering } = useFilterStore()
  const libraryFilterIDs = library.value.filterMatchings.map((obj) => obj.id)

  // Check wether all the button logic is satisfied, and debranch if not
  if (isSubset(touchedButtonFilterIDs(), libraryFilterIDs) == false) {
    return false
  }

  // ... Now range logic must be verified too.
  // We need to check every range filters living in the state
  if (
    rangeFiltering.value.FNbStars.qty > 0 &&
    library.value.nbStars! < rangeFiltering.value.FNbStars.qty
  ) {
    return false
  }
  if (
    rangeFiltering.value.FNbDownloads.qty > 0 &&
    library.value.nbDownloads! < rangeFiltering.value.FNbDownloads.qty * 1000
  ) {
    return false
  }
  if (
    rangeFiltering.value.FNbComponents.qty > 0 &&
    nbComponents < rangeFiltering.value.FNbComponents.qty
  ) {
    return false
  }

  return true
})

const logo = ((): string =>
  colorMode.value == "dark" && library.value.logoDark
    ? library.value.logoDark
    : library.value.logo)()

// Github related ------------------------------------------------------------------------

const repoUrl = ((library: Library): string | undefined =>
  library.github
    ? library.github
    : undefined)(library.value)
type GithubApiResponse = {
  stargazers_count: number // known and useful key
  [key: string]: unknown // unknown and useless keys
}

// if (repoUrl) {
//   const { data: githubApiData } = useFetch<GithubApiResponse>(
//     `https://api.github.com/repos/${library.value.repoOwner}/${library.value.repoName}`,
//     {
//       lazy: true,
//       server: false, // This call will only be performed on the client
//       onResponse({ response }) {
//         library.value.nbStars = response._data.stargazers_count
//       },
//     }
//   )
// }

// NPM related ---------------------------------------------------------------------------

const registryUrl = ((library: Library): string | undefined =>
  library.package ? `https://www.npmjs.com/package/${library.package}` : undefined)(
    library.value
  )

type NpmApiResponse = {
  downloads: number
  [key: string]: unknown
}

// if (registryUrl) {
//   const { data: npmApiData } = useFetch<NpmApiResponse>(
//     `https://api.npmjs.org/downloads/point/last-week/${library.value.package}`,
//     {
//       lazy: true,
//       server: false,
//       onResponse({ response }) {
//         library.value.nbDownloads = response._data.downloads
//       },
//     }
//   )
// }
</script>
